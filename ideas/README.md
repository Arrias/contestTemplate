Некоторые популярные идеи, которые можно встретить в СП
=======================================================

## Одно из главных правил: четко формулируйте цель (бывает, что решается далеко не та задача, которая дана)
## Не забывайте проверять крайние случаи, при построении логики учитывайте их

### Идея приведения чего-то к одному фиксированному виду.

Например, имеем задачу, в которой нужно с помощью каких-то операций получить из одного объекта другой. 
Давайте придумаем универсальную форму, к которой будем приводить объект в начале, а потом работать уже с этой
универсальной формой (к примеру для строк это может быть строка из все "0")

Примеры задач:
* [cf 1381A](<https://codeforces.com/contest/1381/problem/A2>) (Идея в том, чтобы сделать каждую строку из ввода в начале состоящей из всех "0")

### Идея разделения / раскраски. 

Бывают разные прототипы, где-то нужно поделить игральную доску на две симметричные части, в каких-то задачах надо 
для упрощения решения разделить фигуры на меньшие фигуры.
Также тут бывает идея раскраски, когда надо определенный объект раскрасить в разные цвета по определенному правилу
(например, сделать шахматную раскраску доски для некоторых дальнейших размышлений).

Примеры задач:
* [cf 576C](<https://codeforces.com/contest/576/problem/C>) (Поделим квадрат на 1000 прямоугольников, в каждом из которых гарантируем возрастание координаты по Y)
* [timus 1255](<https://acm.timus.ru/problem.aspx?space=1&num=1255>) (Давайте сделаем диагональную раскраску и поймем, что каждый гроб занимает два разных цвета, значит ответ, это мин.количество какого-то цвета)
* [cf 1450C](https://codeforces.com/contest/1450/problem/C1) давайте покрасим доску диагонально в три цвета, потом поймем, что можно всегда свапнуть фигуры одного цвета

### Анализ, а каким бывает определенный объект.

Зачастую можно просто порисовать на бумажке, чтобы понять, каким бывает тот или иной объект. Например, граф слишком ограниченного вида,
или какая-то сложная ситуация никогда не встречается, что очень упрощает решение. Также это относится к оценке асимптотики, если для вас
```O(C(25, 8))``` 
это непонятно сколько и скорее много, то стоит проверить это в 
онлайн калькуляторе, возможно, это быстро. (Например)

Здесь часто помогает следующий пункт (четность/нечетность).

Не забываем, что если в графе у каждой вершины **входящая и исходящая степень 1, тот этот граф это набор циклов.**
Если **только исходящая степень 1, то этот граф это ктулху
с макс одним циклом в компоненте.**

Пробуем оценивать ответ, оцениваем худшие случаи. Оцениваем всё. (Возможно, что ответ достаточно мал)

Примеры задач:
* [cf 1392F](<https://codeforces.com/contest/1392/problem/F>) (Поймём, что бывает максимум одна пара одинаковых высот => составляем уравнение относительно первой высоты)
* [cf 665D](<https://codeforces.com/contest/665/problem/D>) (Поймём, что красивое множество не умеет содержать больше 2 чисел, не равных 1)
* [cf 1391D](<https://codeforces.com/contest/1391/problem/D>) (при ```n>=4 && m>=4``` ответ ```-1```)
* [cf 1461F](<https://codeforces.com/contest/1461/problem/F>) (Считать дп имеет смысл только при определенных ограничениях, которые сильно ускоряет подсчет, иначе же ответ понятен)
* [cf 1442C](<https://codeforces.com/contest/1442/problem/C>) (При больших степенях и так понятно, какой ответ, на маленьких можно посчитать дп)
* [cf 1421E](<https://codeforces.com/contest/1421/problem/E>) (Можно погенерить подходящие перестановки и найти паттерн)
* [cf 1372D](<https://codeforces.com/contest/1372/problem/D>) (Посмотреть, а какие элементы остаются в конце)


### Идея четности/нечетности, разбиения на группы по этому признаку.
В некоторых задачах для построения конструктивного ответа хватает разбиения по принципу "четный-нечетный"

Примеры задач:
* [665D](<https://codeforces.com/contest/665/problem/D>) (см. предыдущий пункт)
* [1270E](<https://codeforces.com/contest/1270/problem/E>)

### Идея оценки ответа
Предположим, что у нас есть задача, 
в которой надо что-то минимизировать.
Давайте оценим ответ снизу. 
Зачастую можно конструктивно построить такой ответ.

Примеры задач:
* [1392C](<https://codeforces.com/contest/1392/problem/C> )
  (Понимаем, что ответ обязательно не меньше
  суммы разностей ```a[i]-a[i+1]```, ```a[i]>a[i+1]```, 
  строим такой ответ с конца)
  
* [Что это?] (https://codeforces.com/contest/1474/problem/E)
  Оценим сверху суммарное кол-во действий стоимости n-1,n-2, ..., n-k
  Заметим, что можно построить ответ, достигающий такого количества действий

### Бинпоиск по ответу
Используйте бинпоиск по 0-1 функции чтобы найти последний верный / первый подходящий ответ.

Примеры задач:
* [1371E](<https://codeforces.com/contest/1371/problem/E2>) (понимаем, что ответом на задачу является непрерывный отрезок и ищем бинпоиском два его конца)
* [1370F](<https://codeforces.com/contest/1370/problem/F2>) (бинпоиск по высоте для нахождения вершин)
* [1370D](<https://codeforces.com/contest/1370/problem/D>) (бинпоиск по ответу и дп)

### Идея закономерностей
Чтобы найти закономерность иногда достаточно вывести 2-ичное представление чисел последовательности, или то, что подходит под задачу.

Примеры задач:
* <https://codeforces.com/contest/1338/problem/C> (выведем двоичное представление и заметим, из каких блоков состоят подходящие числа)

### Некоторые полезные техники

##### нет двух цветов подряд 
* Сначала научимся решать подзадачу для одного яруса: 
  составить гирлянду длины s из лампочек ровно k цветов, 
  так чтобы никакие две лампочки одного цвета не шли подряд.
  При этом варианты, отличающиеся порядком цветов, пока считаем одинаковыми 
  (при необходимости мы всегда успеем домножить на k!). Решение подзадачи нам нужно лишь
  для ```k≤s≤5000```, поэтому считаем динамику за ```O(s^2)```:
 ```a[s][k] = a[s-1][k-1] + a[s-1][k] * (k - 1).  ```
Это были бы [числа Стирлинга второго рода](https://clck.ru/FPsne), если бы не условие, что одинаковые лампочки не могут идти подряд. 

##### массивы с фиксированными количество различных чисел
* Пусть хотим считать сколько существует массивов из n чисел, ```1 <= a[i] <= n```, таких что там ровно k различных чисел.  
Пусть каждое число может быть от ```1``` до ```k```. Тогда просто умножим ответ в конце на ```C(n, k)```  
Предположим, у нас есть ```k``` корзин, 
  значит задача свелась к тому, 
  чтобы посчитать разделения 
  элемента массива по корзинам так, чтобы в каждой корзине было хотя бы одно число.  
Посчитаем обратную величину - количество плохих расстановок.
  Заметим, что мы умеем считать, сколько есть расстановок ровно с t пустыми корзинами. Их ```f(t) = C(k, t) * (k-t)^n```.  
Применим принцип включений исключений: 
  для каждого ```t``` от ```1``` до ```k``` добавим к количеству плохих расстановок 
  ```f(t) * (-1) ^ (1 - t % 2)```. Получим количество плохих расстановок. Отнимем его от ```k^n```.   
Не забываем домножить на биномиальный коэффициент.

##### условие существования упорядоченности отрезков 
* Пусть даны ```n``` отрезков ```[a_n, b_n]```, мы хотим найти
их перестановку, такую что ```b_i != a_{i+1}```. Посчитаем, сколько раз
  каждое число встречается в качестве конца/начала отрезка. Пусть ```c``` максимальное такое значение. Тогда ответ существует, если ```f <= n + 1```.  

### Поиск инвариантов:
* [986B](<https://codeforces.com/contest/986/problem/B>) Например, количество инверсий у перестановки 
* [1392F](<https://codeforces.com/contest/1392/problem/F>) Целью задачи является понять, где прибавляются единички, а где нет,
тогда заметим инвариант, что единицы после каждого преобразования не прибавляются не больше чем в одном месте, переберем его.
  

### Хэширование множеств 

Примеры задач на хэш множеств:
* [154C](https://codeforces.com/problemset/problem/154/C)

### Геометрическое представление параметров
Если в задаче даны несколько параметров, попробуйте графически представить их и применить геометрические алгоритмы.

Примеры задач:
* [1299C](<https://codeforces.com/contest/1299/problem/C>) (Представить числа как точки на плоскости и найти верхнюю огибающую)

### Генерация всех k^n массивов с числами от 1 до k в особых порядках
Например, можно генерировать массивы так, чтобы соседние отличались максимум одним числом, для этого используют алгоритм из книги Шеня (программирование - теоремы и задачи) на странице 49.

для k=2 можно использовать [код грея](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%93%D1%80%D0%B5%D1%8F)

Решение одной из подобных задач (генерация всех перестановок так, чтобы соседние отличались свапом двух чисел лежит в файле Shen в этом репозитории)


### Метод биекции 
Когда одному объекту сопоставляется другой по какому-то признаку, и уже дальше операции идут на втором объекте, на котором проще что-то делать.

К примеру, можно поменять массив на массив разностей соседних элементов.  
Также каждой перестановке ```{x}``` можно однозначно сопоставить массив ```{y}``` , ```y[i]``` означает количество чисел меньших ```i``` и стоящих левее ```i``` в перестановке.

### Решение задачи от обратного  
Предположите, что должно выполняться какое-то условие и попробуйте доказать его корректность, пляшите от этого, корректируйте условие в зависимости от тест кейсов.

### Сведение к графу
В некоторых задачах нужно построить некий граф (к примеру, двудольный) и решать что-то на нем (нужно доказать, что все объекты, которые были в изначальном графе остались и в этом, например, циклы). Если во вводе даны какие-то пары, тройки, 
то можно попытаться применить теорию графов
#### Примеры
* Неравенства между весами вершин можно показать с помощью направленных ребер, задачи [1450E](https://codeforces.com/contest/1450/problem/E)
* [1408E](https://codeforces.com/contest/1408/problem/E)

### Задачи на гормонический ряд 
* [K](https://codeforces.com/gym/278113/problem/K) пересчет дп с помощью гармонического ряда

### Применения снм
Можно применять для любых транзитивных отношений. 
* [1408E](https://codeforces.com/contest/1408/problem/E) Выразить вектора можно тогда и только тогда, когда
между ними есть путь в графе 
  

